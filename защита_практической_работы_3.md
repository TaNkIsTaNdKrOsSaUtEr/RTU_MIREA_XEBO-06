Решение 3ей практической работы, используя все тот же датасет из второй работы.

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans, DBSCAN
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
import warnings
warnings.filterwarnings('ignore')

# 1. Загрузка и изучение данных
print("1. ЗАГРУЗКА И ИЗУЧЕНИЕ ДАННЫХ")
print("="*50)

# Загрузка данных
url = "https://raw.githubusercontent.com/your-repo/bi.csv"  # Замените на реальный путь
df = pd.read_csv('bi.csv', encoding='ISO-8859-1')

# Базовая информация о данных
print("Размер данных:", df.shape)
print("\nПервые 5 строк:")
print(df.head())
print("\nИнформация о данных:")
print(df.info())
print("\nОписательная статистика:")
print(df.describe())
print("\nПропущенные значения:")
print(df.isnull().sum())

# 2. ПРЕДОБРАБОТКА ДАННЫХ
print("\n2. ПРЕДОБРАБОТКА ДАННЫХ")
print("="*50)

# Заполнение пропусков
df['Python'].fillna(df['Python'].mean(), inplace=True)

# Нормализация данных для кластеризации
features = ['Age', 'entryEXAM', 'studyHOURS', 'Python', 'DB']
X = df[features]
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

print("Данные после предобработки готовы для кластеризации")

# 3. ВИЗУАЛИЗАЦИЯ ДАННЫХ
print("\n3. ВИЗУАЛИЗАЦИЯ ДАННЫХ")
print("="*50)

# Создаем grid графиков
fig, axes = plt.subplots(2, 3, figsize=(15, 10))
fig.suptitle('ВИЗУАЛИЗАЦИЯ ДАННЫХ', fontsize=16)

# Распределение возрастов
axes[0,0].hist(df['Age'], bins=15, alpha=0.7, color='skyblue')
axes[0,0].set_title('Распределение возраста')
axes[0,0].set_xlabel('Возраст')
axes[0,0].set_ylabel('Количество')

# Распределение баллов за экзамен
axes[0,1].hist(df['entryEXAM'], bins=15, alpha=0.7, color='lightgreen')
axes[0,1].set_title('Распределение баллов вступительного экзамена')
axes[0,1].set_xlabel('Баллы')
axes[0,1].set_ylabel('Количество')

# Распределение часов обучения
axes[0,2].hist(df['studyHOURS'], bins=15, alpha=0.7, color='salmon')
axes[0,2].set_title('Распределение часов обучения')
axes[0,2].set_xlabel('Часы')
axes[0,2].set_ylabel('Количество')

# Корреляционная матрица
corr_matrix = df[features].corr()
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', ax=axes[1,0])
axes[1,0].set_title('Корреляционная матрица')

# Соотношение Python vs DB
axes[1,1].scatter(df['Python'], df['DB'], alpha=0.6)
axes[1,1].set_title('Python vs Database баллы')
axes[1,1].set_xlabel('Python баллы')
axes[1,1].set_ylabel('DB баллы')

# Распределение по странам (топ-10)
top_countries = df['country'].value_counts().head(10)
axes[1,2].bar(top_countries.index, top_countries.values)
axes[1,2].set_title('Топ-10 стран происхождения')
axes[1,2].tick_params(axis='x', rotation=45)

plt.tight_layout()
plt.show()

# 4. КЛАСТЕРИЗАЦИЯ K-MEANS
print("\n4. КЛАСТЕРИЗАЦИЯ K-MEANS")
print("="*50)

# Определение оптимального числа кластеров (метод локтя)
inertia = []
for k in range(1, 11):
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    kmeans.fit(X_scaled)
    inertia.append(kmeans.inertia_)

plt.figure(figsize=(10, 6))
plt.plot(range(1, 11), inertia, marker='o')
plt.title('Метод локтя для определения оптимального K')
plt.xlabel('Количество кластеров')
plt.ylabel('Inertia')
plt.grid(True)
plt.show()

# Кластеризация с оптимальным K (выберем 3)
kmeans = KMeans(n_clusters=3, random_state=42, n_init=10)
kmeans_labels = kmeans.fit_predict(X_scaled)
df['kmeans_cluster'] = kmeans_labels

print("K-Means кластеризация завершена")
print("Размеры кластеров:")
print(df['kmeans_cluster'].value_counts().sort_index())

# 5. КЛАСТЕРИЗАЦИЯ DBSCAN
print("\n5. КЛАСТЕРИЗАЦИЯ DBSCAN")
print("="*50)

dbscan = DBSCAN(eps=0.8, min_samples=5)
dbscan_labels = dbscan.fit_predict(X_scaled)
df['dbscan_cluster'] = dbscan_labels

print("DBSCAN кластеризация завершена")
print("Распределение кластеров DBSCAN:")
print(pd.Series(dbscan_labels).value_counts().sort_index())
print("(-1 означает выбросы)")

# 6. ВИЗУАЛИЗАЦИЯ РЕЗУЛЬТАТОВ
print("\n6. ВИЗУАЛИЗАЦИЯ РЕЗУЛЬТАТОВ КЛАСТЕРИЗАЦИИ")
print("="*50)

# PCA для визуализации в 2D
pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)

fig, axes = plt.subplots(1, 3, figsize=(18, 6))

# Исходные данные
scatter1 = axes[0].scatter(X_pca[:, 0], X_pca[:, 1], alpha=0.6)
axes[0].set_title('Исходные данные (после PCA)')
axes[0].set_xlabel('Главная компонента 1')
axes[0].set_ylabel('Главная компонента 2')

# K-Means результаты
scatter2 = axes[1].scatter(X_pca[:, 0], X_pca[:, 1], c=kmeans_labels, cmap='viridis', alpha=0.6)
axes[1].set_title('K-Means кластеризация (K=3)')
axes[1].set_xlabel('Главная компонента 1')
axes[1].set_ylabel('Главная компонента 2')
plt.colorbar(scatter2, ax=axes[1])

# DBSCAN результаты
scatter3 = axes[2].scatter(X_pca[:, 0], X_pca[:, 1], c=dbscan_labels, cmap='Set1', alpha=0.6)
axes[2].set_title('DBSCAN кластеризация')
axes[2].set_xlabel('Главная компонента 1')
axes[2].set_ylabel('Главная компонента 2')
plt.colorbar(scatter3, ax=axes[2])

plt.tight_layout()
plt.show()

# 7. АНАЛИЗ КЛАСТЕРОВ
print("\n7. АНАЛИЗ КЛАСТЕРОВ K-MEANS")
print("="*50)

# Статистика по кластерам
cluster_stats = df.groupby('kmeans_cluster')[features].mean()
print("Средние значения по кластерам:")
print(cluster_stats)

# Визуализация характеристик кластеров
plt.figure(figsize=(12, 8))
cluster_stats.T.plot(kind='bar', figsize=(12, 6))
plt.title('Сравнение характеристик кластеров K-Means')
plt.xlabel('Признаки')
plt.ylabel('Средние значения (нормализованные)')
plt.legend(title='Кластер')
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# 8. ИТОГОВАЯ ТАБЛИЦА С РЕЗУЛЬТАТАМИ
print("\n8. ИТОГОВАЯ ТАБЛИЦА (первые 10 строк)")
print("="*50)
result_columns = ['fNAME', 'lNAME', 'Age', 'entryEXAM', 'Python', 'DB', 'kmeans_cluster', 'dbscan_cluster']
print(df[result_columns].head(10))

print("\nЗАДАНИЕ ВЫПОЛНЕНО!")
print("Были выполнены все этапы: предобработка, EDA, кластеризация K-Means и DBSCAN, визуализация результатов.")
```

Этот код выполняет все требования задания:

## Что тут есть:

1. **Загрузка и изучение данных** - базовый анализ датасета
2. **Предобработка** - обработка пропущенных значений, нормализация
3. **EDA** - визуализация распределений, корреляций, scatter plots
4. **K-Means кластеризация** - с определением оптимального числа кластеров
5. **DBSCAN кластеризация** - с обнаружением выбросов
6. **Визуализация результатов** - сравнение методов кластеризации
7. **Анализ кластеров** - интерпретация полученных групп

Результаты показывают, как студенты естественным образом группируются по своим академическим характеристикам и демографическим данным.
